#cria uma grid com 2 linhas e 3 colunas, logo a janela vai ser divida em 6 espaços (2x3)
par(mfrow=c(2,3))
# Histograma para frequência
hist_frequency = hist(airfoil_df$frequencia,
main = "Frequência (Hz)",
xlab = "Hz",
col = "lightblue",
border = "black",
prob = TRUE, breaks = "Sturges")
dens_frequency = density(airfoil_df$frequencia)
lines(dens_frequency, lwd = 2)
polygon(dens_frequency, col = rgb(0.9375, 0.5, 0.5, 0.4), border = NA)
# Teste de kolmogorov
ks.test(jitter(airfoil_df$frequencia), "pnorm", mean(airfoil_df$frequencia), sd(airfoil_df$frequencia))
# Teste de shapiro
shapiro.test(airfoil_df$frequencia)
# Histograma frequência
hist_freq = hist(airfoil_df$angulo_ataque,
main = "Ângulo de Ataque (°)",
xlab = "Graus",
col = "lightblue",
border = "black",
prob = TRUE)
# Linha densidade
dens_attackangle = density(airfoil_df$angulo_ataque)
lines(dens_attackangle, lwd = 2)
polygon(dens_attackangle, col = rgb(0.9375, 0.5, 0.5, 0.4), border = NA)
hist_chordlength = hist(airfoil_df$comprimento_corda,
main = "Comprimento da Corda (m)",
xlab = "m",
col = "lightblue",
border = "black",
prob = TRUE)
dens_chordlength = density(airfoil_df$comprimento_corda)
lines(dens_chordlength, lwd = 2)
polygon(dens_chordlength, col = rgb(0.9375, 0.5, 0.5, 0.4), border = NA)
hist_streamvelocity = hist(airfoil_df$velocidade_fluxo_livre,
main = "Velocidade do Fluxo Livre (m/s)",
xlab = "m/s",
col = "lightblue",
border = "black",
prob = TRUE)
dens_streamvelocity = density(airfoil_df$velocidade_fluxo_livre)
lines(dens_streamvelocity, lwd = 2)
polygon(dens_streamvelocity, col = rgb(0.9375, 0.5, 0.5, 0.4), border = NA)
hist_displacement_thickness = hist(airfoil_df$espessura_deslocamento_sucçao,
main = "Espessura de Deslocamento (m)",
xlab = "m",
col = "lightblue",
border = "black",
prob = TRUE)
dens_displacement_thickness = density(airfoil_df$espessura_deslocamento_sucçao)
lines(dens_displacement_thickness, lwd = 2)
polygon(dens_displacement_thickness, col = rgb(0.9375, 0.5, 0.5, 0.4), border = NA)
hist_soundpressure = hist(airfoil_df$pressao_sonora,
main = "Pressão Sonora (dB)",
xlab = "dB",
col = "lightblue",
border = "black",
prob = TRUE)
dens_soundpressure = density(airfoil_df$pressao_sonora)
lines(dens_soundpressure, lwd = 2)
polygon(dens_soundpressure, col = rgb(0.9375, 0.5, 0.5, 0.4), border = NA)
plot(pressao_sonora ~ frequencia, data = airfoil_df,
main = "Pressão Sonora vs Frequência",
xlab = "Frequência (Hz)", ylab = "Pressão Sonora (dB)",
pch = 19, col = rgb(0.2, 0.4, 0.8, 0.4))
plot(pressao_sonora ~ angulo_ataque, data = airfoil_df,
main = "Pressão Sonora vs Ângulo de Ataque",
xlab = "Ângulo de Ataque (°)", ylab = "Pressão Sonora (dB)",
pch = 19, col = rgb(0.2, 0.4, 0.8, 0.4))
plot(pressao_sonora ~ comprimento_corda, data = airfoil_df,
main = "Pressão Sonora vs Comprimento da Corda",
xlab = "Comprimento da Corda (m)", ylab = "Pressão Sonora (dB)",
pch = 19, col = rgb(0.2, 0.4, 0.8, 0.4))
plot(pressao_sonora ~ velocidade_fluxo_livre, data = airfoil_df,
main = "Pressão Sonora vs Velocidade do Fluxo Livre",
xlab = "Velocidade do Fluxo Livre (m/s)", ylab = "Pressão Sonora (dB)",
pch = 19, col = rgb(0.2, 0.4, 0.8, 0.4))
plot(pressao_sonora ~ espessura_deslocamento_sucçao, data = airfoil_df,
main = "Pressão Sonora vs Espessura de Deslocamento",
xlab = "Espessura de Deslocamento (m)", ylab = "Pressão Sonora (dB)",
pch = 19, col = rgb(0.2, 0.4, 0.8, 0.4))
cor_matrix = cor(airfoil_df)
round(cor_matrix, 3) # arredondar valores
corrplot.mixed(cor_matrix,
upper = "circle",
lower = "number",
tl.cex = 0.8,
order = "AOE",
title = "Correlação")
corrplot(cor_matrix,
method = "number",
type = "lower",
number.cex = 0.7,
title = "Correlação - Valores Numéricos",
tl.cex = 0.8, tl.col = "black", mar = c(0,0,2,0))
corrplot.mixed(cor_matrix,
lower = "shade",
upper = "pie",
order = "hclust",
tl.cex = 0.8,
title = "Matriz de Correlação com Agrupamento Hierárquico")
# Selecionar variável dependente
x <- airfoil_df$pressao_sonora
# Calcular limites para outliers
q1  <- quantile(x, 0.25, na.rm = TRUE)
q3  <- quantile(x, 0.75, na.rm = TRUE)
iqr <- IQR(x, na.rm = TRUE)
low_cut  <- q1 - 1.5 * iqr
high_cut <- q3 + 1.5 * iqr
# --- HISTOGRAMA COM CURVA DE DENSIDADE ---
ggplot(airfoil_df, aes(x = pressao_sonora)) +
geom_histogram(aes(y = ..density..),
fill = "white", color = "black", bins = 30) +
geom_density(fill = "lightcoral", alpha = 0.4, linewidth = 1.2) +
labs(
title = "Histograma com curva de densidade da pressão sonora (Y)",
x = "Pressão sonora (dB)",
y = "Densidade"
) +
theme_minimal(base_size = 14)
# --- BOX PLOT COM LINHAS DOS LIMITES ---
boxplot(x,
main = "Boxplot da pressão sonora (Y)",
ylab = "Pressão sonora (dB)",
col = "lightblue",
border = "darkblue",
horizontal = TRUE,
notch = TRUE)
abline(v = low_cut, col = "red", lty = 2)
abline(v = high_cut, col = "red", lty = 2)
# Ajuste do modelo linear completo
modelo_lm = lm(pressao_sonora ~ ., data = airfoil_df)
# Resumo estatístico do modelo
summary(modelo_lm)
VIF(modelo_lm)
# Seleção stepwise baseada no AIC
# Seleção stepwise bidirecional
modelo_step = stepAIC(modelo_lm, direction = "both", trace = FALSE)
summary(modelo_step)
train_control = trainControl(method = "cv", number = 10)
cv_model = train(
pressao_sonora ~ .,
data = airfoil_df,
method = "lm",
trControl = train_control
)
cv_model
summary(modelo_step)
VIF(modelo_step)
cv_model
#altera o layout da janela
par(mfrow = c(2,2))
plot(modelo_step)
shapiro.test(residuals(modelo_step))
ks.test(
residuals(modelo_step),
"pnorm",
mean(residuals(modelo_step)),
sd(residuals(modelo_step))
)
res <- residuals(modelo_step)
ggplot(data.frame(res), aes(x = res)) +
geom_histogram(aes(y = ..density..),
bins = 30, fill = "lightblue", color = "black") +
geom_density(color = "red", linewidth = 1.2) +
stat_function(fun = dnorm,
args = list(mean = mean(res), sd = sd(res)),
color = "darkgreen", linetype = "dashed", linewidth = 1) +
labs(
title = "Distribuição dos Resíduos do Modelo Stepwise",
x = "Resíduos",
y = "Densidade"
) +
theme_minimal(base_size = 14)
bptest(modelo_step)
knitr::opts_chunk$set(echo = TRUE,fig.align = 'center')
library(tidyverse)
library(janitor)
library(rsample)
library(ggplot2)
library(e1071)
library(regclass)
library(dplyr)
library(UsingR)
library(corrplot)
library(MASS)
library(caret)
library(lmtest)
library(ggcorrplot)
set.seed(2025)
# Importar dataset (.dat)
airfoil_df <- read.table("data/airfoil_self_noise.dat", header = FALSE)
# Adicionar cabeçalho ao dataset
col_names <- colnames(airfoil_df) <- c("frequencia", "angulo_ataque", "comprimento_corda", "velocidade_fluxo_livre","espessura_deslocamento_sucçao", "pressao_sonora")
# Número de colunas do dataset
sprintf("O conjunto de dados usado têm: %d variáveis.", length(col_names))
sprintf("O conjunto de dados usado têm: %d observações.", nrow(airfoil_df))
# Visão geral do dataset
# Glimpse
for (colname in col_names){
print(paste("Column:", colname))
glimpse(airfoil_df[[colname]])
cat("\n")
print(summary(airfoil_df[[colname]]))
cat("\n")
}
#Verificação de valores em falta
missing_data <- sum(is.na(airfoil_df))
sprintf("O número de valores NA é %d", missing_data)
# Verificação para observações (rows) duplicadas.
dup_rows <- sum(duplicated(airfoil_df))
sprintf("O número de observações duplicadas é %d", dup_rows)
# Histograma para frequência
hist_frequency = hist(airfoil_df$frequencia,
main = "Histograma para Frequência (Hz)",
xlab = "Frequência (Hz)",
ylab = "Densidade",
col = "lightblue",
border = "black",
prob = TRUE, breaks = "Sturges")
# Linha de densidade
dens_frequency = density(airfoil_df$frequencia)
lines(dens_frequency, lwd = 2)
polygon(dens_frequency, col = rgb(0.9375, 0.5, 0.5, 0.4), border = NA)
# Histograma para o ângulo de ataque
hist_freq = hist(airfoil_df$angulo_ataque,
main = "Histograma do Ângulo de Ataque",
xlab = "Ângulo de Ataque (°)",
ylab = "Densidade",
col = "lightblue",
border = "black",
prob = TRUE)
# Linha de densidade
dens_attackangle = density(airfoil_df$angulo_ataque)
lines(dens_attackangle, lwd = 2)
polygon(dens_attackangle, col = rgb(0.9375, 0.5, 0.5, 0.4), border = NA)
# Histograma para o comprimento de corda
hist_chordlength = hist(airfoil_df$comprimento_corda,
main = "Histograma do Comprimento de Corda",
xlab = "Comprimento de Corda (m)",
ylab = "Densidade",
col = "lightblue",
border = "black",
prob = TRUE)
# Linha de densidade
dens_chordlength = density(airfoil_df$comprimento_corda)
lines(dens_chordlength, lwd = 2)
polygon(dens_chordlength, col = rgb(0.9375, 0.5, 0.5, 0.4), border = NA)
# Histograma para velocidade de fluxo livre
hist_streamvelocity = hist(airfoil_df$velocidade_fluxo_livre,
main = "Histograma da Velocidade de Fluxo Livre",
xlab = "Velocidade de Fluxo Livre (m/s)",
ylab = "Densidade",
col = "lightblue",
border = "black",
prob = TRUE)
# Linha densidade
dens_streamvelocity = density(airfoil_df$velocidade_fluxo_livre)
lines(dens_streamvelocity, lwd = 2)
polygon(dens_streamvelocity, col = rgb(0.9375, 0.5, 0.5, 0.4), border = NA)
# Histograma para a variável da espessura do deslocamento sucção
hist_displacement_thickness = hist(airfoil_df$espessura_deslocamento_sucçao,
main = "Histograma da Espessura de Deslocamento",
xlab = "Espessura de Deslocamento (m)",
ylab = "Densidade",
col = "lightblue",
border = "black",
prob = TRUE)
# Linha de densidade
dens_displacement_thickness = density(airfoil_df$espessura_deslocamento_sucçao)
lines(dens_displacement_thickness, lwd = 2)
polygon(dens_displacement_thickness, col = rgb(0.9375, 0.5, 0.5, 0.4), border = NA)
# Histograma para o nivel de pressão sonora
hist_soundpressure = hist(airfoil_df$pressao_sonora,
main = "Histograma do Nivel da Pressão Sonora",
xlab = "Nivel da Pressão Sonora (dB)",
ylab = "Densidade",
col = "lightblue",
border = "black",
prob = TRUE)
# Linha de densidade
dens_soundpressure = density(airfoil_df$pressao_sonora)
lines(dens_soundpressure, lwd = 2)
polygon(dens_soundpressure, col = rgb(0.9375, 0.5, 0.5, 0.4), border = NA)
## Correlação entre variáveis
corr_matrix = cor(airfoil_df)
round(corr_matrix, 2) # arredondar valores
invisible(suppressWarnings(
ggcorrplot(corr_matrix, lab = TRUE)
))
# Matriz de correlações
ggcorrplot(
corr_matrix,
lab = TRUE,
lab_size = 3,
digits = 2,
hc.order = TRUE,
tl.cex = 10,
tl.srt = 45
)
# Gráfico de dispersão entre frequencia e nivel de pressão sonora
plot(pressao_sonora ~ frequencia, data = airfoil_df,
xlim = c(min(airfoil_df$frequencia), max(airfoil_df$frequencia)),
ylim = c(min(airfoil_df$pressao_sonora), max(airfoil_df$pressao_sonora)),
main = "Nivel de Pressão Sonora vs Frequência",
xlab = "Frequência (Hz)", ylab = "Nivel de Pressão Sonora (dB)",
pch = 19, col = rgb(0.2, 0.4, 0.8, 0.4))
# Gráfico de dispersão entre ângulo de ataque e nivel de pressão sonora
plot(pressao_sonora ~ angulo_ataque, data = airfoil_df,
xlim = c(min(airfoil_df$angulo_ataque), max(airfoil_df$angulo_ataque)),
ylim = c(min(airfoil_df$pressao_sonora), max(airfoil_df$pressao_sonora)),
main = "Nivel de Pressão Sonora vs Ângulo de Ataque",
xlab = "Ângulo de Ataque (°)", ylab = "Nivel de Pressão Sonora (dB)",
pch = 19, col = rgb(0.2, 0.4, 0.8, 0.4))
# Gráfico de dispersão entre o comprimento de corda e nivel de pressão sonora
plot(pressao_sonora ~ comprimento_corda, data = airfoil_df,
xlim = c(min(airfoil_df$comprimento_corda), max(airfoil_df$comprimento_corda)),
ylim = c(min(airfoil_df$pressao_sonora), max(airfoil_df$pressao_sonora)),
main = "Nivel de Pressão Sonora vs Comprimento da Corda",
xlab = "Comprimento da Corda (m)", ylab = "Nivel de Pressão Sonora (dB)",
pch = 19, col = rgb(0.2, 0.4, 0.8, 0.4))
# Gráfico de dispersão entre a velocidade do fluxo livre e o nivel de pressão sonora
plot(pressao_sonora ~ velocidade_fluxo_livre, data = airfoil_df,
xlim = c(min(airfoil_df$velocidade_fluxo_livre), max(airfoil_df$velocidade_fluxo_livre)),
ylim = c(min(airfoil_df$pressao_sonora), max(airfoil_df$pressao_sonora)),
main = "Nivel de Pressão Sonora vs Velocidade do Fluxo Livre",
xlab = "Velocidade do Fluxo Livre (m/s)", ylab = "Nivel de Pressão Sonora (dB)",
pch = 19, col = rgb(0.2, 0.4, 0.8, 0.4))
# Gráfico de dispersão entre a espessura do deslocamento do lado sucção e o nivel de pressão sonora
plot(pressao_sonora ~ espessura_deslocamento_sucçao, data = airfoil_df,
xlim = c(min(airfoil_df$espessura_deslocamento_sucçao), max(airfoil_df$espessura_deslocamento_sucçao)),
ylim = c(min(airfoil_df$pressao_sonora), max(airfoil_df$pressao_sonora)),
main = "Nivel de Pressão Sonora vs Espessura de Deslocamento",
xlab = "Espessura de Deslocamento (m)", ylab = "Nivel de Pressão Sonora (dB)",
pch = 19, col = rgb(0.2, 0.4, 0.8, 0.4))
# Normalização das variáveis
airfoil_df <- as.data.frame(scale(airfoil_df, center = TRUE, scale = TRUE))
# Novas métricas após scale()
for (colname in col_names) {
cat("\nColumn:", colname, "\n")
print(summary(airfoil_df[, colname]))
}
# Análise de curtose
freq_kurt <- kurtosis(airfoil_df$frequencia)
sprintf("A curtose da frequência é %f", freq_kurt)
angle_kurt <- kurtosis(airfoil_df$angulo_ataque)
sprintf("A curtose do ângulo de ataque é %f", angle_kurt)
vel_kurt <- kurtosis(airfoil_df$velocidade_fluxo_livre)
sprintf(" A curtose da velocidade de fluxo livre é %f", vel_kurt)
comp_kurt <- kurtosis(airfoil_df$comprimento_corda)
sprintf(" A curtose do comprimento de corda é %f", comp_kurt)
espessura_kurt <- kurtosis(airfoil_df$espessura_deslocamento_sucçao)
sprintf(" A curtose da espessura do deslocamento do lado sucção é %f", espessura_kurt)
press_kurt <- kurtosis(airfoil_df$pressao_sonora)
sprintf(" A curtose do nivel de pressão sonora é %f", press_kurt)
# Boxplot para frequência acústica
boxplot(airfoil_df$frequencia,
main = "Boxplot da freqência acústica",
ylab = "Frequência acústica (Hz)",
col = "lightblue",
border = "darkblue",
horizontal = TRUE,
notch = TRUE)
# Boxplot para o ângulo de ataque
boxplot(airfoil_df$angulo_ataque,
main = "Boxplot do ângulo de ataque",
ylab = "Ângulo de ataque (graus)",
col = "lightblue",
border = "darkblue",
horizontal = TRUE,
notch = FALSE)
# Boxplot para o comprimento de corda
boxplot(airfoil_df$comprimento_corda,
main = "Boxplot do comprimento de corda",
ylab = "Comprimento de corda (m)",
col = "lightblue",
border = "darkblue",
horizontal = TRUE,
notch = FALSE)
# Boxplot para a velocidade de fluxo livre
boxplot(airfoil_df$velocidade_fluxo_livre,
main = "Boxplot da velocidade de fluxo livre",
ylab = "Velocidade de fluxo livre (m/s)",
col = "lightblue",
border = "darkblue",
horizontal = TRUE,
notch = FALSE)
# Boxplot para a espessura do deslocamento do lado sucção
boxplot(airfoil_df$espessura_deslocamento_sucçao,
main = "Boxplot da espessura do deslocamento do lado sucção",
ylab = "Espessura do deslocamento do lado sucção (m)",
col = "lightblue",
border = "darkblue",
horizontal = TRUE,
notch = FALSE)
# Boxplot para o nivel de pressão sonora (SPL)
boxplot(airfoil_df$pressao_sonora,
main = "Boxplot do nível de pressão sonora (SPL)",
ylab = "Nivel de pressão sonora (dB)",
col = "lightblue",
border = "darkblue",
horizontal = TRUE,
notch = FALSE)
# Ajuste do modelo linear completo
airfoil_df$espessura_deslocamento_sucçao <- NULL
modelo_lm = lm(pressao_sonora ~ ., data = airfoil_df)
# Resumo estatístico do modelo
summary(modelo_lm)
VIF(modelo_lm)
# Seleção stepwise baseada no AIC
# Seleção stepwise bidirecional
modelo_step = stepAIC(modelo_lm, direction = "both", trace = FALSE)
summary(modelo_step)
train_control = trainControl(method = "cv", number = 10)
cv_model = train(
pressao_sonora ~ .,
data = airfoil_df,
method = "lm",
trControl = train_control
)
cv_model
summary(modelo_step)
VIF(modelo_step)
cv_model
#altera o layout da janela
par(mfrow = c(2,2))
plot(modelo_step)
shapiro.test(residuals(modelo_step))
ks.test(
residuals(modelo_step),
"pnorm",
mean(residuals(modelo_step)),
sd(residuals(modelo_step))
)
res <- residuals(modelo_step)
ggplot(data.frame(res), aes(x = res)) +
geom_histogram(aes(y = ..density..),
bins = 30, fill = "lightblue", color = "black") +
geom_density(color = "red", linewidth = 1.2) +
stat_function(fun = dnorm,
args = list(mean = mean(res), sd = sd(res)),
color = "darkgreen", linetype = "dashed", linewidth = 1) +
labs(
title = "Distribuição dos Resíduos do Modelo Stepwise",
x = "Resíduos",
y = "Densidade"
) +
theme_minimal(base_size = 14)
bptest(modelo_step)
knitr::opts_chunk$set(echo = TRUE)
valores = matrix(c(9830,20,116,34),ncol=2,byrow=TRUE)
valores
colnames(valores) = c("+","-")
rownames(valores) = c("+","-")
colnames(valores) = c("+","-")
rownames(valores) = c("+","-")
valores = as.table(valores)
colnames(valores) = c("+","-")
rownames(valores) = c("+","-")
valores = as.table(valores)
valores
addmargins(valores)
binom.test(116,9946)
binom.test(34,54)
binom.test(9830,9946)
binom.test(34,54)
knitr::opts_chunk$set(echo = TRUE)
valores = matrix(c(9830,20,116,34),ncol=2,byrow=TRUE)
valores
colnames(valores) = c("teste -","teste +")
rownames(valores) = c("nao diabeticos","diabeticos")
valores = as.table(valores)
valores
addmargins(valores)
#verdadeiros positivos
binom.test(9830,9946)
#verdadeiros negativos
binom.test(34,54)
knitr::opts_chunk$set(echo = TRUE)
valores = matrix(c(9830,20,116,34),ncol=2,byrow=TRUE)
valores
colnames(valores) = c("teste -","teste +")
rownames(valores) = c("nao diabeticos","diabeticos")
valores = as.table(valores)
valores
addmargins(valores)
#verdadeiros negativos
binom.test(9830,9946)
#verdadeiros positivos
binom.test(34,54)
install.packages("ggThemeAssist", lib = "/Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/library")
ggThemeAssist:::ggThemeAssistAddin()
ggThemeAssist:::ggThemeAssistAddin()
ggThemeAssist:::ggThemeAssistAddin()
training_data = read.csv('train_Titanic.csv',header=TRUE,na.strings=c(""))
training_data = read.csv('Regressão_mais_2024/train_Titanic.csv',header=TRUE,na.strings=c(""))
View(training_data)
install.package("Amelia")
install.packages("Amelia", lib = "/Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/library")
library(Amelia)
library(Amelia)
sapply(training_data, function(x) sum(is.na(x))))
sapply(training_data, function(x) sum(is.na(x)))
sapply(training_data, function(x) length(unique(x)))
missmap(training_data)
data = subset(training_data,select=c(2,3,5,6,7,8,10,12))
missmap(data,main="Missing values vs observed")
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
